<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fluid Horizon - AI Gameplay</title>
<style>
  html, body {
    margin: 0; padding: 0;
    height: 100%;
    display: flex; justify-content: center; align-items: center;
    background: #000;
    font-family: 'Press Start 2P', sans-serif;
    overflow: hidden;
  }
  canvas {
    display: block;
    background: radial-gradient(circle at center, #0a0a1f, #000);
    border-radius: 12px;
    box-shadow: 0 0 20px #00ffff88;
  }
  #loading {
    position: absolute;
    color: #fff;
    font-size: 1rem;
    top: 10px;
    left: 10px;
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
<div id="loading">Loading AI model...</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js" crossorigin="anonymous"></script>
<script>
(async () => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // 보이는 이미지 크기
  const DRAW_WIDTH = 50;
  const DRAW_HEIGHT = 40;

  // 충돌 판정용 작은 Hitbox
  const PLAYER_WIDTH = 35;   // 이미지보다 작은 충돌 박스
  const PLAYER_HEIGHT = 28;

  const OBSTACLE_WIDTH = 80;
  const GAP_HEIGHT = 200;

  // Load spaceship image
  const shipImg = new Image();
  shipImg.src = "spaceship.png"; // 같은 폴더에 두세요

  // Game state
  let player = { x: 100, y: HEIGHT / 2, vy: 0 };
  let obstacles = [];
  let stars = [];
  let score = 0;
  let gameOver = false;
  const gravity = 0.5;
  const thrust = -10;
  const obstacleSpeed = 5;
  let frameCount = 0;

  // Load ONNX model
  const session = await ort.InferenceSession.create('./model.onnx');
  document.getElementById('loading').style.display = 'none';

  function createObstacle() {
    const gapCenterY = Math.random() * (HEIGHT - GAP_HEIGHT) + GAP_HEIGHT / 2;
    return { x: WIDTH, width: OBSTACLE_WIDTH, gapY: gapCenterY, passed: false };
  }

  function createStars() {
    for (let i = 0; i < 100; i++) {
      stars.push({
        x: Math.random() * WIDTH,
        y: Math.random() * HEIGHT,
        r: Math.random() * 2,
        speed: Math.random() * 1 + 0.5
      });
    }
  }

  function resetGame() {
    player.y = HEIGHT / 2;
    player.vy = 0;
    obstacles = [];
    score = 0;
    gameOver = false;
    frameCount = 0;
  }

  function getClosestObstacle() {
    return obstacles.find(obs => obs.x + OBSTACLE_WIDTH > player.x) || { x: WIDTH, gapY: HEIGHT / 2 };
  }

  function getStateVector() {
    const closest = getClosestObstacle();
    return new Float32Array([
      player.y,
      player.vy,
      closest.x,
      closest.gapY,
      GAP_HEIGHT
    ]);
  }

  async function getAction(stateVec) {
    const tensor = new ort.Tensor('float32', stateVec, [1, stateVec.length]);
    const output = await session.run({ observation: tensor });
    const logits = output.action.data;
    return logits[1] > logits[0] ? 1 : 0;
  }

  async function update() {
    if (gameOver) return;

    const stateVec = getStateVector();
    const action = await getAction(stateVec);
    if (action === 1) player.vy = thrust;

    player.vy += gravity;
    player.y += player.vy;

    if (frameCount % 90 === 0) obstacles.push(createObstacle());

    for (let obs of obstacles) {
      obs.x -= obstacleSpeed;
      // 충돌 판정 (작은 hitbox 사용)
      if (
        player.x + PLAYER_WIDTH / 2 > obs.x &&
        player.x - PLAYER_WIDTH / 2 < obs.x + OBSTACLE_WIDTH &&
        (player.y - PLAYER_HEIGHT / 2 < obs.gapY - GAP_HEIGHT / 2 ||
         player.y + PLAYER_HEIGHT / 2 > obs.gapY + GAP_HEIGHT / 2)
      ) {
        gameOver = true;
      }
      // 점수
      if (!obs.passed && obs.x + OBSTACLE_WIDTH < player.x - PLAYER_WIDTH / 2) {
        score++;
        obs.passed = true;
      }
    }
    obstacles = obstacles.filter(o => o.x + OBSTACLE_WIDTH > 0);

    for (let s of stars) {
      s.x -= s.speed;
      if (s.x < 0) {
        s.x = WIDTH;
        s.y = Math.random() * HEIGHT;
      }
    }
    frameCount++;
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background stars
    ctx.fillStyle = '#fff';
    for (let s of stars) {
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Player (draw spaceship image at larger size)
    if (shipImg.complete) {
      ctx.drawImage(shipImg, player.x - DRAW_WIDTH / 2, player.y - DRAW_HEIGHT / 2, DRAW_WIDTH, DRAW_HEIGHT);
    } else {
      // fallback
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(player.x - DRAW_WIDTH / 2, player.y - DRAW_HEIGHT / 2, DRAW_WIDTH, DRAW_HEIGHT);
    }

    // Obstacles
    for (let obs of obstacles) {
      const neon = ctx.createLinearGradient(obs.x, 0, obs.x + OBSTACLE_WIDTH, 0);
      neon.addColorStop(0, '#00ffffaa');
      neon.addColorStop(1, '#00ff99aa');
      ctx.fillStyle = neon;
      ctx.fillRect(obs.x, 0, OBSTACLE_WIDTH, obs.gapY - GAP_HEIGHT / 2);
      ctx.fillRect(obs.x, obs.gapY + GAP_HEIGHT / 2, OBSTACLE_WIDTH, HEIGHT - (obs.gapY + GAP_HEIGHT / 2));
    }

    // Score
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P"';
    ctx.fillText(`SCORE: ${score}`, 20, 30);

    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#ff5555';
      ctx.font = '24px "Press Start 2P"';
      ctx.fillText('GAME OVER', WIDTH / 2 - 100, HEIGHT / 2);
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px "Press Start 2P"';
      ctx.fillText('CLICK TO RESTART', WIDTH / 2 - 100, HEIGHT / 2 + 40);
    }
  }

  async function gameLoop() {
    await update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  canvas.addEventListener('click', () => {
    if (gameOver) resetGame();
  });

  createStars();
  gameLoop();
})();
</script>
</body>
</html>
