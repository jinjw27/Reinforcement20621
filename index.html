<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fluid Horizon - Improved AI Gameplay</title>
<style>
  html, body {
    margin: 0; padding: 0;
    height: 100%;
    display: flex; justify-content: center; align-items: center;
    background: #000;
    font-family: 'Press Start 2P', sans-serif;
    overflow: hidden;
  }
  canvas {
    display: block;
    background: radial-gradient(circle at center, #0a0a1f, #000);
    border-radius: 12px;
    box-shadow: 0 0 20px #00ffff88;
  }
  #loading {
    position: absolute;
    color: #fff;
    font-size: 1rem;
    top: 10px;
    left: 10px;
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
<div id="loading">Loading AI model...</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js" crossorigin="anonymous"></script>
<script>
(async () => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  const DRAW_WIDTH = 50;
  const DRAW_HEIGHT = 40;
  const PLAYER_WIDTH = 35;
  const PLAYER_HEIGHT = 28;

  // Improved jump / gravity for smoother flight
  const OBSTACLE_WIDTH = 40;
  const GAP_HEIGHT = 280;  // Slightly narrower for smoother AI decision
  const thrust = -10;      // Reduced jump power
  const gravity = 0.38;    // Slightly increased gravity
  const obstacleSpeed = 5;
  const obstacleInterval = 120;

  // Load spaceship image
  const shipImg = new Image();
  shipImg.src = "spaceship.png";

  let player = { x: 100, y: HEIGHT / 2, vy: 0 };
  let obstacles = [];
  let stars = [];
  let score = 0;
  let gameOver = false;
  let frameCount = 0;

  const session = await ort.InferenceSession.create('./model.onnx');
  document.getElementById('loading').style.display = 'none';

  function createObstacle() {
    const minY = GAP_HEIGHT / 2 + 50;
    const maxY = HEIGHT - GAP_HEIGHT / 2 - 50;
    const gapCenterY = Math.random() * (maxY - minY) + minY;
    return { x: WIDTH, width: OBSTACLE_WIDTH, gapY: gapCenterY, passed: false };
  }

  function createStars() {
    stars = [];
    for (let i = 0; i < 100; i++) {
      stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, r: Math.random() * 2, speed: Math.random() * 1 + 0.5 });
    }
  }

  function resetGame() {
    player = { x: 100, y: HEIGHT / 2, vy: 0 };
    obstacles = [];
    score = 0;
    gameOver = false;
    frameCount = 0;
    createStars();
  }

  function getClosestObstacle() {
    return obstacles.find(obs => obs.x + OBSTACLE_WIDTH > player.x) || { x: WIDTH, gapY: HEIGHT / 2 };
  }

  function getStateVector() {
    const closest = getClosestObstacle();
    // Add relative top and bottom gap info for smoother decision
    const relGapTop = (closest.gapY - GAP_HEIGHT / 2 - player.y) / HEIGHT;
    const relGapBottom = (closest.gapY + GAP_HEIGHT / 2 - player.y) / HEIGHT;
    return new Float32Array([
      (player.y - HEIGHT/2) / (HEIGHT/2),
      player.vy / 10,
      (closest.x - player.x) / WIDTH,
      (closest.gapY - HEIGHT/2) / (HEIGHT/2),
      GAP_HEIGHT / HEIGHT,
      relGapTop,
      relGapBottom
    ]);
  }

  async function getAction(stateVec) {
    const tensor = new ort.Tensor('float32', stateVec, [1, stateVec.length]);
    const output = await session.run({ observation: tensor });
    const logits = output.action.data;
    return logits[1] > logits[0] ? 1 : 0;
  }

  async function update() {
    if (gameOver) return;

    // Call AI every 2 frames for smoother movement
    let action = 0;
    if (frameCount % 2 === 0) {
      const stateVec = getStateVector();
      action = await getAction(stateVec);
    }
    if (action === 1) player.vy = thrust;

    player.vy += gravity;
    player.y += player.vy;

    if (frameCount % obstacleInterval === 0) obstacles.push(createObstacle());

    for (let obs of obstacles) {
      obs.x -= obstacleSpeed;
      if (player.x + PLAYER_WIDTH / 2 > obs.x &&
          player.x - PLAYER_WIDTH / 2 < obs.x + OBSTACLE_WIDTH &&
          (player.y - PLAYER_HEIGHT / 2 < obs.gapY - GAP_HEIGHT / 2 ||
           player.y + PLAYER_HEIGHT / 2 > obs.gapY + GAP_HEIGHT / 2)) {
        gameOver = true;
      }
      if (!obs.passed && obs.x + OBSTACLE_WIDTH < player.x - PLAYER_WIDTH / 2) {
        score++;
        obs.passed = true;
      }
    }
    obstacles = obstacles.filter(o => o.x + OBSTACLE_WIDTH > 0);

    for (let s of stars) {
      s.x -= s.speed;
      if (s.x < 0) { s.x = WIDTH; s.y = Math.random() * HEIGHT; }
    }
    frameCount++;
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    ctx.fillStyle = '#fff';
    for (let s of stars) {
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fill();
    }

    if (shipImg.complete) {
      ctx.drawImage(shipImg, player.x - DRAW_WIDTH / 2, player.y - DRAW_HEIGHT / 2, DRAW_WIDTH, DRAW_HEIGHT);
    } else {
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(player.x - DRAW_WIDTH / 2, player.y - DRAW_HEIGHT / 2, DRAW_WIDTH, DRAW_HEIGHT);
    }

    for (let obs of obstacles) {
      const neon = ctx.createLinearGradient(obs.x, 0, obs.x + OBSTACLE_WIDTH, 0);
      neon.addColorStop(0, '#00ffffaa');
      neon.addColorStop(1, '#00ff99aa');
      ctx.fillStyle = neon;
      ctx.fillRect(obs.x, 0, OBSTACLE_WIDTH, obs.gapY - GAP_HEIGHT / 2);
      ctx.fillRect(obs.x, obs.gapY + GAP_HEIGHT / 2, OBSTACLE_WIDTH, HEIGHT - (obs.gapY + GAP_HEIGHT / 2));
    }

    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P"';
    ctx.fillText(`SCORE: ${score}`, 20, 30);

    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#ff5555';
      ctx.font = '24px "Press Start 2P"';
      ctx.fillText('GAME OVER', WIDTH / 2 - 100, HEIGHT / 2);
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px "Press Start 2P"';
      ctx.fillText('CLICK TO RESTART', WIDTH / 2 - 100, HEIGHT / 2 + 40);
    }
  }

  async function gameLoop() {
    await update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  canvas.addEventListener('click', () => { if (gameOver) resetGame(); });

  createStars();
  gameLoop();
})();
</script>
</body>
</html>
